%
% File ucca_parsing.tex
%

\documentclass[11pt]{article}

\usepackage{acl2015}
\usepackage{times}
\usepackage{url}
\usepackage{latexsym}
\usepackage{pgfplotstable}
\usepackage{filecontents}
\usepackage[]{algorithm2e}
\usepackage{ifpdf}
\ifpdf
  \usepackage{hyperref}
\else
  \usepackage[hypertex]{hyperref}
\fi
\bibliographystyle{acl}

\title{Transition-based Parsing of Universal Conceptual Cognitive Annotation}

\author{Daniel Hershcovich \\
  Institute of Computer Science \\
  Hebrew University of Jerusalem \\
  {\tt danielh@cs.huji.ac.il} \\\And
  Second Author \\
  Affiliation / Address line 1 \\
  Affiliation / Address line 2 \\
  Affiliation / Address line 3 \\
  {\tt email@domain} \\}

\date{}

\begin{document}
\maketitle
\begin{abstract}
  Universal Conceptual Cognitive Annotation (UCCA) is a semantic grammatical scheme that assigns a complete structure to natural language text. We present the first automatic UCCA parser, a transition-based parser using a novel transition system. We compare the results to baselines obtained by converting UCCA to CoNNL-X, and training syntactic parsers on the converted dependency trees.
\end{abstract}

\section{Introduction}

Universal Conceptual Cognitive Annotation (UCCA) is a recently introduced semantic annotation scheme. It takes a semantic approach to grammatical representation, describing relations between words and phrases in natural language text. The foundational layer can potentially be extended by any number of additional layers to provide refinements to the existing scheme, but it already covers many of the basic semantic relations in language. The annotation is represented as a directed acyclic graph (DAG), where edges denote semantic dependencies between abstract units. UCCA can be easily annotated manually without expert knowledge in linguistics, making it attractive as a resource for semantic tasks---an alternative to syntactic annotation, which is costly. A corpus containing 160K words from the English Wikipedia has been manually annotated~\cite{abend2013universal}.

This work is the first attempt at automatic UCCA parsing.

\section{Related work}

Even though UCCA parsing is a novel task, it bears resemblance to several other tasks in natural language processing. The techniques used in this work are inspired by solutions for some of them.

\subsection{Dependency parsing}

In a UCCA graph, labels appear on the edges, whereas nodes are unlabeled. If all the nodes are known, parsing is the same as inducing a graph on them with the correct edge labels. In dependency parsing, a graph is induced on the set of nodes consisting of the tokens in the sentence (and the \texttt{ROOT} symbol). Therefore, it seems that techniques from dependency parsing can be used for UCCA parsing as well.

Dependency parsers can be divided to \textit{graph-based} and \textit{transition-based} parsers. 

Graph-based parsers attempt to find a maximal sub-graph of the full graph on the nodes according to some objective function, and tend to scale as $\mathcal{O}(n^3)$ where $n$ is the sentence length. A UCCA parser should parse a whole passage at once, since there may be sentence-crossing edges. This makes it impractical to use graph-based parsers for UCCA parsing.

Transition-based parsers treat parsing as a series of \textit{transitions}, each evoked by an \textit{action} typically chosen by a local classifier. Actions may manipulate data structures or add edges to the result set, which eventually determines the graph produced by the parser. The number of transitions in the simple form of transition-based dependency parsing is always $2n$~\cite{nivre2004incrementality}.

Standard transition-based dependency parsers produce \textit{projective} graphs, but dependency graphs may in general be \textit{non-projective}. Intuitively, this means there are edges crossing each other in a planar arrangement of the graph. In English, only a very small part of sentences exhibit a non-projective dependency graph, so many parsers choose to ignore the problem, suffering a small loss in performance. However, some parsers are capable of producing non-projective graphs, with a number of transitions that is $\mathcal{O}(n^2)$ in the worst case, but $\mathcal{O}(n)$ on average~\cite{nivre2009non}.

\subsection{Constituent parsing}

Although the labels in a UCCA graph are on the edges, it is similar to phrase structure grammar: non-terminal units are internal nodes in the graph, rather than all the edges being between words in the original sentence. In a constituency tree, constituents form a hierarchy above the words of the sentence.

Methods for constituent parsing can also be useful for UCCA parsing, but the common chart-based approach is also $\mathcal{O}(n^3)$ at best. However, there are also transition-based constituent parsers~\cite{zhu2013fast} with linear run-time complexity.

As standard dependency parsers, transition-based constituent parsers are generally unable to produce \textit{discontinuous constituents} (the equivalent of non-projective dependency trees)~\cite{maier2015discontinuous}.

\subsection{AMR parsing}

UCCA is similar to AMR~\cite{flanigan2014discriminative,artzi2015broad}.

\section{Baselines}

To our knowledge, there is no existing model to learn the general structure of UCCA graphs. Instead, as a baseline, we use models originally designed for syntactic dependency parsing, and train them on converted UCCA graphs. Since the converted annotation is not as rich as the UCCA scheme, some information is lost and has to be recovered as part of the conversion, so the accuracy of this method is bounded by the conversion accuracy.

\subsection{Conversion Scheme}

Since existing dependency parsers rely on specific annotation formats that are different from the UCCA graph annotation, we had to perform a conversion. We chose the CoNLL-X format, which is common among dependency parsers.
The top two rows in Table~\ref{table:convert} show the accuracy of conversion from UCCA to CoNLL-X and then back to UCCA.

\subsubsection{Conversion from UCCA to CoNLL-X}

The conversion relies on several concepts: since UCCA has non-terminal units, whereas in CoNLL-X all edges are between tokens, each non-terminal unit $u$ in UCCA requires a representative terminal unit $t$ to be selected for it. $t$ is referred to as the \textit{head terminal} of $u$, and denoted $head(u)$. The edges on the path from $u$ to $t$ are referred to as \textit{head edges}, and the target of a head edge is a \textit{head child}. The head terminal of a unit is selected by selecting a head child iteratively. The head child tag of $u$ is the first among a pre-determined list of tags of which $u$ has outgoing edges, and the head child is any child of that type. The list of tags is: \texttt{C,H,P,S,A,D,E,R,F,L,LR,LA,G,T,U}.

Since UCCA forms a DAG and not necessarily a tree, $t$ can be the head terminal of more than one unit. A \textit{top headed unit} of $t$ is any non-terminal unit $u$ such that $t$ is a head terminal of $u$, but not of any of $u$'s parents (if there are any). Denote by $top(t)$ an arbitrarily selected top headed unit of $t$.

The conversion is shown in Algorithm~\ref{alg:ucca2conll}.

\begin{algorithm}
 \KwData{UCCA graph}
 \KwResult{CoNLL-X dependency tree}
 $nodes \leftarrow []$\;
 \ForEach{terminal unit t}{
  $u \leftarrow top(t)$\;
  $p \leftarrow parent(u)$\;
  $t^\prime \leftarrow head(p)$\;
  $e \leftarrow (p, u)$\;
  add $t$ to $nodes$ with $t^\prime$ as parent, and $tag(e)$ as relation\;
 }
 \caption{UCCA to CoNLL-X Conversion}
 \label{alg:ucca2conll}
\end{algorithm}

\subsubsection{Conversion from CoNLL-X to UCCA}

A UCCA graph is created from a CoNLL-X dependency annotation using the following procedure: first, the dependency nodes (the tokens) are sorted topologically.

When a new edge is added, its tag is either the relation associated with the corresponding dependency arc, or, if no such arc exists, determined heuristically:
\begin{itemize}
\item If the child is a punctuation terminal, the tag is $U$;
\item otherwise, if the parent has a child with an $H$ tag, the tag is also $H$;
\item otherwise, if the parent has a child with an $A$ tag, the tag is $P$;
\item otherwise, the tag is $C$.
\end{itemize}

Algorithm~\ref{alg:conll2ucca} shows the conversion.

\begin{algorithm}
 \KwData{CoNLL-X dependency tree}
 \KwResult{UCCA graph}
 add root unit $r$\;
 \ForEach{node t}{
  add terminal unit $t$\;
  add non-terminal unit $u$\;
  add edge $(u,t)$\;
  \eIf{$rel(t) = $ROOT}{
   add edge $(r,u)$
  }{
   $p \leftarrow preterminal(parent(t))$\;
   add edge $(p,u)$\;
  }
 }
 \caption{CoNLL-X to UCCA Conversion}
 \label{alg:conll2ucca}
\end{algorithm}

\subsection{Parsing Converted Trees}

In order to provide a baseline for UCCA parsing, we trained two state-of-the-art dependency parsers on a dataset resulting from conversion of the UCCA corpus to CoNLL-X format. Then we ran the resulting parser models, converted the results to the UCCA format, and evaluated using the labeled F1, unlabeled F1 and weakly labeled F1 measures. The results are shown in Table~\ref{table:convert}.

\section{Direct Parsing}

Many approaches could be used to create a parser for UCCA, such as the graph-based approach employed in JAMR~\cite{flanigan2014discriminative}.
However, UCCA is annotated over whole passages. A passage can contains hundreds and even thousands of tokens, so it is not feasibly to keep a dense graph over all of them in memory. Therefore, we chose to adopt the transition-based approach for parsing UCCA.

A simple dependency parser uses the arc-standard transition system~\cite{nivre2004incrementality}:

\texttt{Left-Reduce, Right-Reduce, Shift}

or the arc-eager transition system:

\texttt{Left-Edge, Right-Edge, Reduce, Shift}

We chose the arg-eager system, because it allows adding parents to nodes before all their children have been attached to them. This is crucial to reduce the number of actions required for parsing a passage.

The transition systems above only work for projective graphs. Since the UCCA graph is in general non-projective, we added a \texttt{Swap} operation~\cite{nivre2009non}.

However, this is not sufficient since in contrast to normal dependency parsing, in UCCA there are internal nodes (non-terminal units). we could reduce them to their head terminals if there was a one-to-one correspondence, but this is not possible since there are also nodes with a single child. This is similar to constituency parsing, so we added the \texttt{Node} operation (adding a unary parent) and the \texttt{Finish} operation~\cite{zhu2013fast}.

Unlike constituency parsing, in UCCA there may be long-distance edges, called remote edges. We added actions to create remote edges, namely \texttt{Left-Remote} and \texttt{Right-Remote}.

Since some non-terminal units are implicit units, meaning they do not correspond to any terminals, we added the \texttt{Implicit} action: it is just like the \texttt{Node} action, but the unary parent created by it is marked implicit.

When a node has no more parents to create, it must be attached to the \texttt{ROOT} node. If we had included the \texttt{ROOT} node as an element in the stack, we would have to wait for a node to move next to it in order to attach that node and reduce it. Instead, we chose to omit the \texttt{ROOT} node, treating it as an abstract element instead, and add a \texttt{Root} action that acts as a shortcut, attaching its operand to the root and reducing it.

Finally, since UCCA has a layered structure, with just the actions specified above, the parser would just parse the first layer and then reach an empty buffer, unable to continue. To resolve this problem, we add an automatic action, \texttt{Wrap}, that happens only when the buffer is empty. This action empties the stack and fills the buffer with the nodes in the same order.
The final action set is thus:

\texttt{Node, Implicit, Left-Edge, Right-Edge, Left-Remote, Right-Remote, Root, Reduce, Shift, Swap, Wrap, Finish}

\section{Experiments}

\begin{table*}
\pgfplotstabletypeset[col sep=comma,
     columns={Method,LAS,LAS (sentences),UAS,UAS (sentences),labeled F1,labeled F1 (sentences),unlabeled F1,unlabeled F1 (sentences),weak labeled F1,weak labeled F1 (sentences)},
     columns/Method/.style={string type, column type=l,
         postproc cell content/.code={%
             \pgfplotsutilstrreplace{_}{\_}{##1}%
             \pgfkeyslet{/pgfplots/table/@cell content}\pgfplotsretval
         },}
    ]{/cs/nlp/danielh/workspace/ucca/latest/results.csv}
\caption{Results of Conversion and Annotation using Dependency Parsers}
\label{table:convert}
\end{table*}


\section{Conclusion}

Future work:
\begin{itemize}
\item \texttt{smatch} for scoring
\item find the best conversion rules automatically
\end{itemize}

\bibliography{ucca}

\begin{filecontents}{ucca.bib}
@InProceedings{nivre2004incrementality,
  author    = {Nivre, Joakim},
  title     = {Incrementality in Deterministic Dependency Parsing},
  booktitle = {Proceedings of the ACL Workshop Incremental Parsing: Bringing Engineering and Cognition Together},
  editor    = {Frank Keller and Stephen Clark and Matthew Crocker and Mark Steedman},
  year      = 2004,
  month     = {July},
  address   = {Barcelona, Spain},
  publisher = {Association for Computational Linguistics},
  pages     = {50--57},
  url       = {http://aclweb.org/anthology/W04-0308}
}
@InProceedings{nivre2009non,
  author    = {Nivre, Joakim},
  title     = {Non-Projective Dependency Parsing in Expected Linear Time},
  booktitle = {Proceedings of the Joint Conference of the 47th Annual Meeting of the ACL and the 4th International Joint Conference on Natural Language Processing of the AFNLP},
  month     = {August},
  year      = {2009},
  address   = {Suntec, Singapore},
  publisher = {Association for Computational Linguistics},
  pages     = {351--359},
  url       = {http://aclweb.org/anthology/P09-1040}
}
@InProceedings{abend2013universal,
  author    = {Abend, Omri  and  Rappoport, Ari},
  title     = {{U}niversal {C}onceptual {C}ognitive {A}nnotation ({UCCA})},
  booktitle = {Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers)},
  month     = {August},
  year      = {2013},
  address   = {Sofia, Bulgaria},
  publisher = {Association for Computational Linguistics},
  pages     = {228--238},
  url       = {http://aclweb.org/anthology/P13-1023}
}
@InProceedings{zhu2013fast,
  title     = {Fast and Accurate Shift-Reduce Constituent Parsing},
  author    = {Zhu, Muhua and Zhang, Yue and Chen, Wenliang and Zhang, Min and Zhu, Jingbo},
  booktitle = {Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics},
  year      = {2013},
  address   = {Sofia, Bulgaria},
  publisher = {Association for Computational Linguistics},
  pages     = {434--443},
  url       = {http://aclweb.org/anthology/P13-1043}
}
@InProceedings{flanigan2014discriminative,
  author    = {Flanigan, Jeffrey  and  Thomson, Sam  and  Carbonell, Jaime  and  Dyer, Chris  and  Smith, Noah A.},
  title     = {A Discriminative Graph-Based Parser for the {A}bstract {M}eaning {R}epresentation},
  booktitle = {Proceedings of the 52nd Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers)},
  month     = {June},
  year      = {2014},
  address   = {Baltimore, Maryland},
  publisher = {Association for Computational Linguistics},
  pages     = {1426--1436},
  url       = {http://aclweb.org/anthology/P14-1134}
}
@InProceedings{artzi2015broad,
  author    = {Artzi, Yoav  and  Lee, Kenton  and  Zettlemoyer, Luke},
  title     = {Broad-coverage {CCG} Semantic Parsing with {AMR}},
  booktitle = {Proceedings of the 2015 Conference on Empirical Methods in Natural Language Processing},
  month     = {September},
  year      = {2015},
  address   = {Lisbon, Portugal},
  publisher = {Association for Computational Linguistics},
  pages     = {1699--1710},
  url       = {http://aclweb.org/anthology/D15-1198}
}
@InProceedings{maier2015discontinuous,
  author    = {Maier, Wolfgang},
  title     = {Discontinuous Incremental Shift-reduce Parsing},
  booktitle = {Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing (Volume 1: Long Papers)},
  month     = {July},
  year      = {2015},
  address   = {Beijing, China},
  publisher = {Association for Computational Linguistics},
  pages     = {1202--1212},
  url       = {http://aclweb.org/anthology/P15-1116}
}
\end{filecontents}

\end{document}
