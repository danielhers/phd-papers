%
% File completeness_proof.tex
%

\documentclass[11pt,a4paper]{article}
\usepackage[hyperref]{acl2017}
\usepackage{times}
\usepackage{url}
\usepackage{latexsym}
\usepackage{amsmath}
\usepackage{breqn}
\usepackage{pgfplotstable}
\usepackage{algorithm2e}
\usepackage{hhline}
\usepackage{multirow}
\usepackage[font=small]{caption}
\usepackage{subcaption}
\usepackage{color}
\usepackage{float}
\usepackage{lipsum,adjustbox}
\usepackage{tikz}
\usepackage{tikz-dependency}
\usepackage{enumitem}
\usepackage{xr}
\externaldocument{acl2017_supp}
\usetikzlibrary{shapes,fit,calc,er,positioning,intersections,decorations.shapes,mindmap,trees}
\tikzset{decorate sep/.style 2 args={decorate,decoration={shape backgrounds,shape=circle,
      shape size=#1,shape sep=#2}}}
\newcommand{\oa}[1]{\footnote{\color{red} #1}}
\newcommand{\daniel}[1]{\footnote{\color{blue} #1}}
\newcommand{\com}[1]{}
\newcommand{\parser}[1]{TUPA\textsubscript{#1}}
\newcommand{\secref}[1]{Section~\ref{#1}}
\newcommand{\figref}[1]{Figure~\ref{#1}}
\newcommand{\tabref}[1]{Table~\ref{#1}}
\DeclareMathOperator*{\argmin}{argmin}
\DeclareMathOperator*{\argmax}{argmax}
\SetKwRepeat{Do}{do}{while}

\hyphenation{SemEval}
\hyphenation{PARSEVAL}
\hyphenation{DAGParser}
\hyphenation{TurboSemanticParser}
\hyphenation{MaltParser}

\def\linkspace#1#2{\leavevmode
\def\tmp##1{\nolinebreak[2]\href{#1}{\hbox{##1}}}%
\xlinkspace#2 \relax}

\def\xlinkspace#1 #2{%
 \ifx\relax#2%
 \xlinkdash#1-\relax
 \else
 \xlinkdash#1 -\relax
 \expandafter\xlinkspace\expandafter#2%
 \fi}

\def\xlinkdash#1-#2{%
 \ifx\relax#2%
 \tmp{#1}%
 \else
 \tmp{#1-}%
 \expandafter\xlinkdash\expandafter#2%
 \fi}

%\aclfinalcopy % Uncomment this line for the final submission
\def\aclpaperid{***} %  Enter the acl Paper ID here

%\setlength\titlebox{5cm}
% You can expand the titlebox if you need extra space
% to show all the authors. Please do not make the titlebox
% smaller than 5cm (the original size); we will check this
% in the camera-ready version and ask you to change it back.

\title{Completeness and Soundness of Transition Systems for DAG Parsing}

\author{Daniel Hershcovich$^{1,2}$ \\
  $^1$The Edmond and Lily Safra Center for Brain Sciences \\
  $^2$School of Computer Science and Engineering \\
  Hebrew University of Jerusalem \\
  \texttt{danielh@cs.huji.ac.il}
}

\date{}

\begin{document}
\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%     Abstract     %%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}
\end{abstract}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}\label{sec:introduction}

Transition-based parsing is a widely used framework for natural language parsing.
Transition-based parsers scan the text from start to end,
and create the parse incrementally by applying a \textit{transition}
at each step to the parser's state,
defined using three data structures: a buffer $B$ of tokens and nodes to be processed,
a stack $S$ of nodes currently being processed,
and a graph $G=(V,E,\ell)$ of constructed nodes and edges,
where $V$ is the set of \emph{nodes}, $E$ is the set of \emph{edges},
and $\ell : E \to L$ is the \emph{label} function, $L$ being the set of possible labels.
Some states are marked as \textit{terminal}, meaning that $G$ is the final output.
A classifier is used at each step to select the next transition based on features
encoding the parser's current state.
During training, an oracle creates training instances for the classifier,
based on gold-standard annotations.

Many variations to this model have been proposed, such as using more than one stack to support
non-projective dependency parsing \cite{gomez2010a},
as well as easy-first parsing rather than following the order of tokens \cite{goldberg2010efficient}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Completeness}\label{sec:completeness}

Here we sketch a proof for the fact that the transition set defined in \cite{hershcovich2017a}
is capable of producing any rooted, labeled, anchored DAG.
This proves that the transition set is complete with respect to the class of graphs that
comprise UCCA.

Let $G=(V,E,\ell)$ be a graph with labels $\ell:E\rightarrow L$
over a sequence of tokens $w_1, \ldots, w_n$.
Parsing starts with $w_1, \ldots, w_n$ on the buffer,
and the root node on the stack.

First we show that every node can be created, by induction on the node height:
every terminal (height zero) already exists at the beginning of the parse
(and so does the root node).
Let $v\in V$ be of height $k$, and assume all nodes of height less than $k$ can be created.
Take any (primary) child $u$ of $v$: its height must be less than $k$.
If $u$ is a terminal, apply \textsc{Shift} until it lies at the head of the buffer.
Otherwise, by our assumption, $u$ can still be created.
Right after $u$ is created, it lies at the head of the buffer.
A \textsc{Shift} transition followed by a \textsc{Node}$_{\ell(v,u)}$ transition will
move $u$ to the stack and create $v$ on the buffer, with the correct edge label.

Next, we show that every edge can be created.
Let $(v,u) \in E$ be any edge with parent $v$ and child $u$.
Assume $v$ and $u$ have both been created (we already showed that both are created eventually).
If either $v$ or $u$ are in the buffer, apply \textsc{Shift} until both are in the stack.
If both are in the stack but neither is at the stack top, apply \textsc{Swap} transitions
until either moves to the buffer, and then apply \textsc{Shift}.
Now, assume either $v$ or $u$ is at the stack top.
If the other is not the second element on the stack, apply \textsc{Swap} transitions until it is.
Finally, $v$ and $u$ are the top two elements on the stack.
If they are in that order, apply \textsc{Right-Edge}$_{\ell(v,u)}$
(or \textsc{Right-Remote}$_{\ell(v,u)}$ if the edge between them is remote).
Otherwise, apply \textsc{Left-Edge}$_{\ell(v,u)}$
(or \textsc{Left-Remote}$_{\ell(v,u)}$ if the edge between them is remote).
This creates $(v,u)$ with the correct edge label.

Once all nodes and edges have been created, we can apply \textsc{Reduce} until only the
root node remains on the stack, and then \textsc{Finish}.
This yields exactly the graph $G$.

Note that the distinction we made between primary and remote transitions is suitable for UCCA parsing.
For general graph parsing without this distinction,
the \textsc{Remote} transitions can be removed, as well as the single-primary-parent
restriction on \textsc{Edge} transition.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Soundness}\label{sec:soundness}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section*{Acknowledgments}
%
%This work was supported by the HUJI Cyber Security Research Center
%in conjunction with the Israel National Cyber Bureau in the Prime Minister's Office,
%and by the Intel Collaborative Research Institute for Computational Intelligence (ICRI-CI).
%The first author was supported by a fellowship from the
%Edmond and Lily Safra Center for Brain Sciences.
%We thank Wolfgang Maier, Nathan Schneider, Elior Sulem
%and the anonymous reviewers for their helpful comments.


\bibliography{references}
\bibliographystyle{acl_natbib}

\end{document}

